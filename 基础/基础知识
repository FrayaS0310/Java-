1、面向对象和面向过程的区别：
面向过程：面向过程性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，
比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。
面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、
更加易于维护。但是，面向对象性能比面向过程低。
2、Java“白皮书”的关键术语：
(1)简单性
(2)面向对象
(3)分布式：Java有一个例程库，用于处理像HTTP和FTP之类的TCP/IP协议。
(4)健壮性：Java采用的指针模型可以消除重写内存和损坏数据的可能性(与C++相比)。
(5)安全性：使用Java可以构建防病毒、防篡改的系统。
(6)体系结构中立
(7)可移植性(Java虚拟机实现平台无关性)
(8)解释型
(9)高性能
(10)多线程(C++没有内置的多线程机制，必须调用操作系统的多线程功能来进行多线程程序设计，而Java提供了多线程支持)
(11)动态性(Java能够适应不断发展的环境)
3、关于JVM、JDK和JRE：
(1)JVM：Java虚拟机(JVM)是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现，目的是使用相同的字节码，他们都会给出相同的结果。
(2)JDK：即Java Development Kit，他是功能齐全的Java SDK，他拥有JRE所拥有的一切，还有编译器(javac)和工具(例如javadoc和jdb)，
他能够创建和变异程序。
(3)JRE：即Java运行时环境，他是运行已编译的Java程序所需的所有内容的集合，包括Java虚拟机(JVM)、Java类库、Java命令和其他的一些
基础组件，他不能用于创建新程序。
4、Java和C++
(1)都是面向对象的语言，都支持封装、继承和多态；
(2)Java不提供指针来直接访问内存，程序内存更加安全；
(3)Java的类是单继承的，C++支持多重继承，Java可以通过接口实现多重继承；
(4)Java有自动内存管理机制，不需要程序员手动释放无用内存。
5、Java程序的主类：一个程序中可以有多个类，但是只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类，而在Java
小程序中，这个主类是一个继承自JApplet或Applet的子类。应用程序的主类不一定要求是public的，但小程序的主类要求必须是public类。主类
是Java程序执行的入口点。应用程序从主线程启动(即main()方法)，而小程序是嵌在浏览器页面上运行(调用init()或者run()来启动)。
6、数据类型：Java是一种强类型语言，即必须为每一个变量声明一种类型，在Java中，一共有8种基本类型，其中有4种整型、2种浮点类型、1种
用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。
7、字符型常量和字符串常量的区别：
(1)形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符；
(2)含义上：字符常量相当于一个整型值(ASCII值)，可以参加表达式运算，字符串常量代表一个地址(该字符串在内存中存放地址)；
(3)占内存大小：字符常量只占2个字节，字符串常量占若干个字节(至少一个字符结束标志)。
8、Java面向对象编程有三大特性：封装、继承、多态
(1)封装：把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。
(2)继承：使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或者新的功能，也可以使用父类的功能，但不能选择性地
继承父类
    A.子类拥有父类对象所有的属性和方法(包括私有属性和私有方法)，但是父类中的私有属性和私有方法子类无法访问，只是拥有；
    B.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；
    C.子类可以用自己的方法实现父类的方法。
(3)多态：指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行时才确定，即一个引用
变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。Java中有两种形式可以
实现多态：继承(多个子类对同一方法的重写)和接口(实现接口并覆盖接口中同一方法)。
9、重载和重写的区别：
(1)重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时；
(2)重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于父类，抛出的异常范围小于父类，访问修饰符范围大于等于父类；如果父类
方法访问修饰符为private则子类就不能重写该方法。
10、构造器：构造器是一种特殊的方法，用来构造并初始化对象，构造器的名字应该与类名相同。构造器不可以被override(重写)，但是可以
overload(重载)，即一个类可以有多个构造器。
11、String StringBuffer和StringBuilder：
(1)可变性：String类中使用final关键字修饰字符数组来保护字符串，private final char value[]，所以String对象是不可变的。而StringBuilder
和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，但是没有用final关键字
修饰，因此这两种对象都是可变的。
(2)线程安全性：String中的对象是不可变的，也就可以理解为常量，线程安全。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以
是线程安全的。StringBuilder没有对方法加同步锁，因此是非线程安全的。
(3)性能：每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer
对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%～15%左右的性能提升，
却要冒多线程不安全的风险。
(4)总结
A.操作少量的数据，用String；
B.单线程操作字符串缓冲区下操作大量数据，用StringBuilder；
C.多线程操作字符串缓冲区下操作大量数据，用StringBuffer。
12、自动装箱与拆箱：
(1)装箱：将基本类型用它们对应的引用类型包装起来；
(2)拆箱：将包装类型转换为基本数据类型。
13、由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。
14、构造方法的主要作用是完成对类对象的初始化工作，可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。在Java中定义一个
不做事且没有参数的构造方法的作用：java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，就会调用父类中"没有参数的
构造方法"。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中有没有用super()来调用父类中特定的构造方法，则编译时将发生错误，
因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法就是在父类中加上一个不做事且没有参数的构造方法。构造方法的特性：
(1)名字与类名相同；
(2)没有返回值，但不能用void声明构造函数；
(3)生成类的对象时自动执行，无需调用。
15、接口和抽象类：
(1)接口的方法默认是public,所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现)，而抽象类可以有非抽象的方法；
(2)接口中除了static、final变量，不能有其他变量，而抽象类不一定；
(3)一个类可以实现多个接口，但只能实现一个抽象类，接口自己本身可以通过extends关键字扩展多个接口；
(4)接口方法默认修饰符为public，抽象方法可以有public、protected和default这些修饰符(抽象方法就是为了被重写所以不能用private关键字修饰)；
(5)从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。
16、成员变量和局部变量：
(1)从语法形式上来看：成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数，成员变量可以背public、private、static等修饰符所修饰，
而局部变量不能被访问控制修饰符及static所修饰，但是，成员变量和局部变量都能被final所修饰。
(2)从变量在内存中的存储方式来看：如果成员变量使用static修饰，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的，
而对象存在于堆内存，局部变量存在于栈内存。
(3)从变量在内存中的生存时间上看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
(4)成员变量如果没有被赋初值则会自动以类型的默认值而赋值(一种情况例外：被final修饰的成员变量也必须显示地赋值)，而局部变量则不会自动赋值。
17、创建一个对象用new运算符，new创建对象实例(对象实例在堆内存中)，对象引用指向对象实例(对象引用存放在栈内存)。一个对象引用可以指向0或1个对象，
一个对象可以有n个引用指向。
18、方法的返回值是指我们获取到的某个方法提中的代码执行后产生的结果。返回值的作用：接收出结果，使得它可以用于其他操作。
19、静态方法和实例方法：
(1)在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式，而实例方法只有后面这种方式。也就是说，调用静态方法无需
创建对象；
(2)静态方法在访问本类的成员时，只允许静态成员(即静态成员变量和静态方法)，而不允许访问实例成员变量和实例方法，实例方法则无此限制。
20、对象的相等，比的是内存中存放的内容是否相等；而引用相等，比较的是他们指向的内存地址是否相等。
21、==与equals：
(1)==：它的作用是判断两个对象的地址是不是相等，即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)；
(2)equals：它的作用也是判断两个对象是否相等，但它一般有两种使用情况：
A.类没有覆盖equals()方法，则等价于"==";
B.类覆盖了equals()方法，一般，我们都覆盖equals()方法来比较两个对象的内容是否相等，若它们的内容相等，则返回true。
(3)编写一个完美的equals方法的建议：
A.显示参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量；
B.检测this与otherObject是否引用同一个对象；
C.检测otherObject是否为null，如果为null，则返回false；
D.比较this与otherObject是否属于同一个类，
E.将otherObject转换为相应的类类型变量；
F.对所有需要比较的域进行比较。
22、hashCode与equals
(1)hashCode：hashCode()的作用是获取哈希码，也称为散列码，它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置，
hashCode()定义在JDK的Object.java中，这就意味着Java中的任何类都包含hashCode()函数。散列表存储的是键值对(key-value)，它的特点是：能根据"键"
快速的检索出对应的"值"，这其中就利用了散列码(可以快速找到所需要的对象)。
(2)hashCode()与equals()的相关规定：
A.如果两个对象相等，则hashcode一定也是相同的；
B.两个对象相等，对两个对象分别调用equals方法都返回true；
C.两个对象有相同的hashcode值，它们也不一定相等；
D.equals方法被覆盖，则hashCode方法也必须被覆盖；
E.hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写hashCode()，则该类的两个对象无论如何也不会相等。
23、为什么Java中只有值传递：
(1)按值调用(call by value)表示方法接受的是调用者提供的值，而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址，一个方法可以
修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。
(2)Java总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。
24、线程、程序、进程
(1)线程与进程相似，但线程是一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组
系统资源，所以系统在产生一个线程，或者是在各个线程之间作切换工作时，负担要比进程小的多，也正因为如此，线程也被称为轻量级进程。
(2)程序：是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
(3)进程：程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的，系统运行一个程序即是一个进程从创建、运行到消亡的过程。简单来说，一个进程就是
一个执行中的程序，他在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间、内存空间、文件、输入输出设备的使用权等等，
换句话说，当程序在运行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，
因为统一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一时间内，可以同时执行一个以上的程序，而线程则是在统一程序内
几乎同时执行一个以上的程序段。
25、线程的状态：
(1)线程创建之后，它将处于NEW(新建)状态，调用start()方法后开始运行，处于READY(可运行状态)，可运行状态的线程获得了cpu时间片后处于RUNNING(状态)，当
线程执行wait()方法之后，线程进入WAITING(等待)状态，进入等待状态的线程需要依靠其他线程的通知才能够返回运行状态，而TIME_WAITING(超时等待)状态相当于
在等待状态的基础上增加了超时限制，当超时时间到达后Java线程将会返回到RUNNABLE状态，当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到
BLOCKED(阻塞)状态，线程在执行Runnable的run()方法之后将会进入到TERMINATED(终止)状态。
26、异常
(1)在Java中，所有的异常都有一个共同的祖先java.lang包中的Throwable类，其中有两个重要的子类：Exception(异常)和Error(错误)。
(2)Error(错误)：是程序无法处理的错误，表示运行程序中较严重的问题，多数错误与代码编写者执行的操作无关，而表示代码运行时JVM出现的问题。
(3)Exception(异常)：是程序本身可以处理的异常。
(4)常用方法：
A.public String getMessage()：返回异常发生时的简要描述；
B.public String toString()：返回异常发生时的详细信息；
C.public String getLocalizedMessage()：返回异常对象的本地化信息；
D.public void printStackTrace()：在控制台打印Throwable对象封装的异常信息。
(5)异常处理：
A.try块：用于捕获异常，其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块；
B.catch块：用于处理try捕获到的异常；
C.finally块：无论是否捕获或处理异常，finally块里的语句都会被执行，当在try块或catch块中遇到return语句时，finally块在方法返回之前被执行。
D.在一下四种特殊情况下，finally块不会被执行：
a.在finally语句块的第一句发生了异常；
b.在前面的代码中用了System.exit(int)已退出程序；
c.程序所在线程死亡；
d.关闭cpu。
27、键盘输入：
(1)通过Scanner
(2)通过BufferedReader
28、static、final、this、super：
(1)final：
A.final变量：如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
B.当用final修饰一个类时，表明这个类不能被继承，final类中的所有成员方法都会被隐式地指定为final方法。
C.使用final方法的原因有两个，第一个原因是把方法锁定，以防任何继承类修改他的含义；第二个原因是效率。
(2)static：
A.修饰成员变量和成员方法：被static修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static声明的
成员变量属于静态成员变量，被static声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区，调用格式：类名.静态变量名、类名.静态方法名()。
B.静态代码块：静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行(静态代码块->非静态代码块->构造方法)。该类不管创建多少对象，静态代码块
只执行一次。
C.静态内部类(static修饰的话只能修饰内部类)：静态内部类与非静态内部类之间存在一个最大的区别，即非静态内部类在编译完成之后会隐含地保存着一个引用，该
引用是指向创建它的外围类，但是静态内部类却没有。
D.静态导包
(3)this：用来引用类的当前实例。
(4)super关键字：用于从子类访问父类的变量和方法.
29、Collections工具类和Arrays工具类常见方法：
(1)Collections：
A.排序
a.void reverse(List list)//反转
b.void shuffle(List list)//随机排序
c.void sort(List list)//按自然排序的升序排列
d.void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
e.void swap(List list, int i, int j)//交换两个索引位置的元素
f.void rotate(List list, int distance)//旋转，当distance为正数时，将list后distance个元素整体移到前面，当distance为负数时，将list的前
distance个元素整体移到后面。
B.查找，替换操作
a.int binarySearch(List list, Object key)//对List进行二分查找，返回索引，list必须是有序的
b.int max(Collection coll)//根据元素的自然排序，返回最大的元素
c.int max(Collection coll, Comparator c)//根据定制排序，返回最大元素
d.void fill(List list, Object obj)//用指定的元素代替制定list中的所有元素
e.int frequency(Collection c, Object o)//统计元素出现次数
f.int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到就返回-1
g.bollean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
(2)Arrays：
A.排序：sort()
B.查找：binarySearch()
C.比较：equals()
D.填充：fill()
E.转列表：asList()
F.转字符串：toString()
G.复制：copyOf()
30、深拷贝和浅拷贝：
(1)浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递；
(2)深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。
